# [437] 路径总和
```
给定一个二叉树，它的每个结点都存放着一个整数值。

找出路径和等于给定数值的路径总数。

路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。

示例：

root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

返回 3。和等于 8 的路径有:

1.  5 -> 3
2.  5 -> 2 -> 1
3.  -3 -> 11
```

内置函数想要访问外置变量，需要强调nonlocal。

本题的想法来源跟回溯公式很像，我们在遍历的过程中需要知道自己所处的位置，同时我们也要有一个中间结果。

这道题不需要回溯，那么我们只需要记录遍历到每个节点额中间结果就行，中间结果就是每一个父节点开始算起，到除了本节点的最近父亲节点的路径和数组，有了这个数组，我们计算一下本节点满不满足要求，以及数组上的每个数字和本节点数值之和满不满足要求即可。

```
class Solution:
    def pathSum(self, root: TreeNode, sum: int) -> int:
        res=0
        def dfs(nums,currentNode):
            nonlocal res
            if currentNode == None:
                return
            for num in nums:
                if currentNode.val + num == sum:
                    res+=1
            nums.append(currentNode.val)
            if currentNode.val == sum:
                res+=1
            for index in range(0,len(nums)-1):
                nums[index]+=currentNode.val
            dfs(list(nums),currentNode.left)
            dfs(list(nums),currentNode.right)
        dfs([],root)
        return res
```