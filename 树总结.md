# 三种遍历的方法

对于dfs来说，
先序无非是
dfs
    get mid
    dfs(left)
    dfs(right)

中序是
dfs
    dfs(left)
    get mid
    dfs(right)

后序是
dfs
    dfs(left)
    dfs(right)
    dfs(mid)


但是对于这三种遍历顺序，如果不让用dfs怎么处理？

这个时候的做法是利用栈来处理，其中最重要的原则是谁从栈先出来，就是先访问谁。

对于先序遍历来说，中间结点先添加进栈，然后中间结点出栈当作被访问，而后是右侧进栈，然后是左侧进栈，循环往复。

只有这样，出栈之后的排列才是 中--左--右。（右侧结点先进栈后出栈）。

对于后序遍历来说，其需要左，右，中。也就是说，我们利用先序遍历的思路，进行中，右，左得到序列，而后对序列进行反转，即可得到后序遍历。而不需要真正的后序遍历。

## [145] 后序遍历
```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        stack = []
        result = []
        origin = root
        if root == None:
            return []
        stack.append(root)
        while len(stack)!=0:
            t = stack.pop()
            result.append(t.val)
            #left
            if t.left!=None:
                stack.append(t.left)
            #right
            if t.right!=None:
                stack.append(t.right)
        result.reverse()
        return result
```

## [94] 中序遍历

中序遍历是个人认为最复杂的迭代方式。

原则没变，还是谁先出栈就是先访问谁。

所以出来的顺序应该是左，中，右。所以中间结点要在左结点入栈前入栈。

```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        if root==None:
            return None
        if root == []:
            return []
        ss = []
        res = []
        origin = root
        ss.append(root)
        while len(ss)!=0:
            while root.left!=None:
                ss.append(root.left)
                root=root.left
            t = ss.pop() # 左先出栈 中间结点要出栈的时候，指针还是指向其左孩子
            res.append(t.val)
            if t.right!=None:
                ss.append(t.right) # 中间结点出栈后，右结点就可以进栈了
                root=t.right # 更新指针位置 开展新一轮
        return res
```


# 层序遍历

层序遍历也是分dfs和非dfs。

对于dfs做法很好理解，dfs(root,deep)。

对于dfs函数，第二个参数作为记录遍历的深度，方便往结果添加内容。

迭代法也可以做层序遍历。同样利用栈或者队列来做。

只不过栈或者队列入栈的不仅仅是结点，而应该是[结点，所在层数]，以数组形式进入栈或者队列。

下面的代码是以队列为目标。

## [102] 层序遍历
```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        q = []
        if root == None:
            return []
        q.append([root,1])
        res=[]
        while len(q)!=0:
            node = q[0]
            if node[1]>len(res):
                res.append([node[0].val])
            else:
                res[node[1]-1].append(node[0].val)
            if node[0].left!=None:
                q.append([node[0].left,node[1]+1])
            if node[0].right!=None:
                q.append([node[0].right,node[1]+1])
            q.pop(0)
        return res
```


# 二叉搜索树
