# [338] 比特位计数

```
给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

示例 1:

输入: 2
输出: [0,1,1]
示例 2:

输入: 5
输出: [0,1,1,2,1,2]

```

题目的意思是：从0到num的所有数字，这些数字的bit位为1的个数总和为一个数，这些数组成数组。

## 暴力法:
每个数字认真的数一遍。
```
class Solution:
    def countBits(self, num: int) -> List[int]:
        def countOne(n):
            res = 0
            while n!=0:
                if n%2 == 1:
                    res+=1
                n=int(n/2)
            return res
        l=[]
        for i in range(0,num+1):
            l.append(countOne(i))
        return l
```

## 动态规划法：

数字x的bit结果为p(x)

p(x) = p(x/2) + ( x mod 2 )

```
class Solution:
    def countBits(self, num: int) -> List[int]:
        res = []
        res.append(0)
        for index in range(1,num+1): # [1,num]
            res.append(res[int(index/2)]+(index&1))
        return res
```


# [279] 完全平方数

```
给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

示例 1:

输入: n = 12
输出: 3 
解释: 12 = 4 + 4 + 4.
示例 2:

输入: n = 13
输出: 2
解释: 13 = 4 + 9.

```

完全平方数，这道题的平方数必须自己生成。

想法是从穷举开始的，比如f(12) = min (f(11)+1,f(8)+1,f(3)+1) 。 （上一次的结果加一个平方数的1）

这个就是穷举的办法，dp只不过是缓存了f的结果，避免二次进入函数进行计算


```
class Solution:
    def numSquares(self, n: int) -> int:
        d = []
        for i in range(1,n):
            if i*i > n:
                break
            d.append(i*i)
        dp=[0 for x in range(0,n+1)]
        dp[1]=1
        def dfs(x,d):
            if x==0:
                return 0
            if x==1:
                return 1
            if dp[x]!=0:
                return dp[x]
            r=float('inf')
            for index in range(0,len(d)):
                if d[index]>x:
                    break
                r=min(r,dfs(x-d[index],d)+1)
            dp[x]=r
            return r
        return dfs(n,d)
```
