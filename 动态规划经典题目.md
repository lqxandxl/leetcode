## 动态规划的思想来源

动态规划思想和分治算法接近。都是通过子问题的解来求解原问题。

分治算法的不同之处： 子问题不重叠。

动态规划的不同之处： 子问题重叠。

动态规划有两种思考方式：

1）自顶向下： 递归解决，只不过在递归的过程中保存中间计算结果。不重复进入递归进行多余的计算。

2）自底向上： 由小问题解决之后，从而解决大问题。

最优子结构的概念理解：

局部的最优可以推导出全局的最优。

状态转移方程是解决动态规划最关键的方程，其说白了就是递推关系式，是子问题如何解决最终问题的本质规律。

# 一维动态规划

### [70] 爬楼梯

```
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶

```

只能一次爬一个台阶，或者两个台阶是最关键的。

假如一次只能爬一个台阶，那么dp[3] = dp[2] = dp[1]

当前还可以一次爬两个台阶，那么dp[3] = dp[3-1] + dp[3-2]

状态转移方程
```
dp[n] = dp[n-1] + dp[n-2]
```

### [198] 打家劫舍

```
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

 

示例 1：

输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 2：

输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

假设n为房屋长度。简化数量，简化思考难度，从而去思考。

dp[1] = nums[1]

dp[2] = max(nums[1],nums[2])

dp[3] = (2没被抢劫+3被抢,2被抢劫) = (dp[3-2]+nums[3] , dp[2])

dp[n] = max(dp[n-2]+nums[n],dp[n-1])


### [413] 等差数列划分 （可不看，太特殊）

```
如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。

例如，以下数列为等差数列:

1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9
以下数列不是等差数列。

1, 1, 2, 5, 7
 

数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0<=P<Q<N 。

如果满足以下条件，则称子数组(P, Q)为等差数组：

元素 A[P], A[p + 1], ..., A[Q - 1], A[Q] 是等差的。并且 P + 1 < Q 。

函数要返回数组 A 中所有为等差数组的子数组个数。

 

示例:

A = [1, 2, 3, 4]

返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。

```

题意理解： 两个数构不成等差数列。至少要三个数。

假如我们有一个函数judge可以判断数组是否为等差数列，复杂度O(N)。

穷举：

一个数组长度为n，那么包括自身，长度至少为3的子数组有多少个？

假如x为解。

n=3，x=1=1

n=4，x=2+1=3

n=5，x=3+2+1=6

数组长度由起点和终点坐标决定，那么其可以画为一个二维矩阵。

也就是大概有n^2/2左右数量级的子数组，再辅以O(N)判断是否为等差数列。共计O(N^3)复杂度。

从穷举的过程中，我们是否发现了重复计算的影子。

也就是说，我们应该优先找到等差数列的段落。假如有三个等差数列的段落分布在三处且不连续。那么等差数列的数量和应该是这三段的和。

每一段应该有一个特别的解。即n=y,那么x=y-2+y-1+...+1=(1+y-2)*(y-2)/2

```
class Solution:
    def numberOfArithmeticSlices(self, A: List[int]) -> int:
        if len(A)<=2:
            return 0
        res = 0
        count = 0
        for i in range(0,len(A)-2):
            if A[i]-A[i+1] == A[i+1]-A[i+2]:
                count+=1
            else:
                if count!=0:
                    res+=(1+count)*(count)//2
                count=0
        if count!=0:
            res+=(1+count)*(count)//2            
        return res
```


dp解法：

dp[i]表示数组A[0, i]相比于A[0, i-1]多出来的等差数列的个数。注意是多出来的等差数列，所以最终的结果是每一位上dp[i]相加得到的结果。

例如：A=[1,2,3,4]，dp[0] = 0，dp[1] = 0，dp[2]=1 相比于dp[1] 多出来一个等差数列1,2,3；dp[3] = dp[2]+1=2，即相比dp[2]多出来两个等差数列2,3,4和1,2,3,4。所以最终sum=dp[0]+dp[1]+dp[2]+dp[3]=3个。

```
public class Solution {
    public int numberOfArithmeticSlices(int[] A) {
        int[] dp = new int[A.length];
        int sum = 0;
        for (int i = 2; i < dp.length; i++) {
            if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {
                dp[i] = 1 + dp[i - 1];
                sum += dp[i];
            }
        }
        return sum;
    }
}
```
dp的解法是对上述数学解法的简洁过程，难以发现。






