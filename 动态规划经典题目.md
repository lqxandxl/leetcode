## 动态规划的思想来源

动态规划思想和分治算法接近。都是通过子问题的解来求解原问题。

分治算法的不同之处： 子问题不重叠。

动态规划的不同之处： 子问题重叠。

动态规划有两种思考方式：

1）自顶向下： 递归解决，只不过在递归的过程中保存中间计算结果。不重复进入递归进行多余的计算。

2）自底向上： 由小问题解决之后，从而解决大问题。

最优子结构的概念理解：

局部的最优可以推导出全局的最优。

状态转移方程是解决动态规划最关键的方程，其说白了就是递推关系式，是子问题如何解决最终问题的本质规律。

# 一维动态规划

### [70] 爬楼梯

```
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶

```

只能一次爬一个台阶，或者两个台阶是最关键的。

假如一次只能爬一个台阶，那么dp[3] = dp[2] = dp[1]

当前还可以一次爬两个台阶，那么dp[3] = dp[3-1] + dp[3-2]

状态转移方程
```
dp[n] = dp[n-1] + dp[n-2]
```

### [198] 打家劫舍

```
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

 

示例 1：

输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 2：

输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

假设n为房屋长度。简化数量，简化思考难度，从而去思考。

dp[1] = nums[1]

dp[2] = max(nums[1],nums[2])

dp[3] = (2没被抢劫+3被抢,2被抢劫) = (dp[3-2]+nums[3] , dp[2])

dp[n] = max(dp[n-2]+nums[n],dp[n-1])

# 二维动态规划

### [64] 最小路径和

```
给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```


建立二维dp。

```
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        row = len(grid)
        if row==0:
            return 0
        col = len(grid[0])
        dp=[]
        for i in range(0,row):
            dp.append([0 for j in range(0,col)])
        for i in range(0,row):
            for j in range(0,col):
                if i==0 and j==0:
                    dp[0][0] = grid[0][0]
                elif i==0:
                    dp[i][j] = dp[i][j-1]+grid[i][j]
                elif j==0:
                    dp[i][j] = dp[i-1][j]+grid[i][j]
                else:
                    dp[i][j] = grid[i][j]+min(dp[i-1][j],dp[i][j-1])
        return dp[row-1][col-1]
```






